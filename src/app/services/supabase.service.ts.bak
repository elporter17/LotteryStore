import { Injectable } from '@angular/core';
import { createClient, SupabaseClient, User as SupabaseUser } from '@supabase/supabase-js';
import { environment } from '../../environments/environment';
import { User, Sale, SaleDetail, Sorteo, SorteoSchedule, SORTEO_SCHEDULES } from '../models/interfaces';
import { Observable, BehaviorSubject } from 'rxjs';
import { format, parseISO } from 'date-fns';
import { toZonedTime, fromZonedTime, formatInTimeZone } from 'date-fns-tz';
import { es } from 'date-fns/locale';

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  private supabase: SupabaseClient;
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser$ = this.currentUserSubject.asObservable();



  constructor() {
    this.supabase = createClient(environment.supabase.url, environment.supabase.key);
    
    // Inicializar sesión existente
    this.initializeSession();
    
    // Escuchar cambios en la autenticación
    this.supabase.auth.onAuthStateChange(async (event, session) => {
      if (session?.user && session.user.email) {
        // Determinar rol basado en email
        const userData: User = {
          id: session.user.id,
          email: session.user.email,
          role: session.user.email === 'gerencia@loteria.com' ? 'admin' : 'sucursal',
          sucursal: this.getSucursalFromEmail(session.user.email),
          active: true,
          createdAt: new Date()
        };
        
        this.currentUserSubject.next(userData);
      } else {
        this.currentUserSubject.next(null);
      }
    });
  }

  // Inicializar sesión existente
  private async initializeSession(): Promise<void> {
    try {
      const { data: { session }, error } = await this.supabase.auth.getSession();
      
      if (error) {
        this.currentUserSubject.next(null);
        return;
      }
      
      if (session?.user && session.user.email) {
        // Determinar rol correctamente basado en el email
        const userData: User = {
          id: session.user.id,
          email: session.user.email,
          role: session.user.email === 'gerencia@loteria.com' ? 'admin' : 'sucursal',
          sucursal: this.getSucursalFromEmail(session.user.email),
          active: true,
          createdAt: new Date()
        };
        
        this.currentUserSubject.next(userData);
      } else {
        this.currentUserSubject.next(null);
      }
    } catch (error) {
      this.currentUserSubject.next(null);
    }
  }

  // Cargar datos del usuario en segundo plano
  private async loadUserDataInBackground(uid: string): Promise<void> {
    try {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Background load timeout')), 5000);
      });
      
      const queryPromise = this.supabase
        .from('users')
        .select('*')
        .eq('id', uid)
        .single();
      
      const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;
      
      if (data && !error) {
        const updatedUser: User = {
          id: data.id,
          email: data.email,
          role: data.role,
          sucursal: data.sucursal,
          active: data.active,
          createdAt: new Date(data.created_at)
        };
        this.currentUserSubject.next(updatedUser);
      }
    } catch (error) {
      // No hacer nada, mantener los datos por defecto
    }
  }

  // Autenticación
  async login(email: string, password: string): Promise<User | null> {
    try {
      const { data, error } = await this.supabase.auth.signInWithPassword({
        email,
        password
      });

      if (error) {
        throw error;
      }

      if (data.user && data.user.email) {
        // Crear datos del usuario basado en el email
        const userData: User = {
          id: data.user.id,
          email: data.user.email,
          role: data.user.email === 'gerencia@loteria.com' ? 'admin' : 'sucursal',
          sucursal: this.getSucursalFromEmail(data.user.email),
          active: true,
          createdAt: new Date()
        };
        
        this.currentUserSubject.next(userData);
        return userData;
      }

      return null;
    } catch (error) {
      throw error;
    }
  }

  private getSucursalFromEmail(email: string): string {
    if (email === 'gerencia@loteria.com') return '';
    if (email.includes('venta1')) return 'Sucursal 1';
    if (email.includes('venta2')) return 'Sucursal 2';
    if (email.includes('venta3')) return 'Sucursal 3';
    if (email.includes('venta4')) return 'Sucursal 4';
    return 'Principal';
  }

  async logout(): Promise<void> {
    const { error } = await this.supabase.auth.signOut();
    if (error) throw error;
  }

  // Verificar conexión a la base de datos
  async testConnection(): Promise<boolean> {
    try {
      const { data, error } = await this.supabase
        .from('usuarios')
        .select('count')
        .limit(1);
      
      return !error;
    } catch (error) {
      return false;
    }
  }

  // Usuarios
  async getUserData(uid: string): Promise<User | null> {
    try {
      // Primero obtener datos básicos de auth
      const { data: authUser, error: authError } = await this.supabase.auth.getUser();
      
      if (authError || !authUser.user) {
        return null;
      }

      // Datos por defecto usando auth
      const defaultUserData: User = {
        id: authUser.user.id,
        email: authUser.user.email || '',
        role: 'sucursal' as const,
        sucursal: 'Principal',
        active: true,
        createdAt: new Date()
      };

      // Intentar obtener datos de la tabla users con timeout muy corto
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Database timeout')), 1000); // 1 segundo timeout
        });
        
        const queryPromise = this.supabase
          .from('users')
          .select('*')
          .eq('id', uid)
          .single();
        
        const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;
        
        if (data && !error) {
          return {
            id: data.id,
            email: data.email,
            role: data.role,
            sucursal: data.sucursal,
            active: data.active,
            createdAt: new Date(data.created_at)
          } as User;
        }
      } catch (dbError) {
        // Error/timeout consultando tabla users, usar datos por defecto
      }

      return defaultUserData;
      
    } catch (error) {
      return null;
    }
  }

  // Ventas
  async getNextCorrelativo(sucursal: string): Promise<number> {
    try {
      // Obtener el correlativo más alto para esta sucursal en el día actual
      const today = new Date();
      const startOfDay = new Date(today);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(today);
      endOfDay.setHours(23, 59, 59, 999);
      
      // Obtener solo las del día actual
      const { data, error } = await this.supabase
        .from('sales')
        .select('correlativo, fecha, created_at')
        .eq('sucursal', sucursal)
        .gte('fecha', startOfDay.toISOString())
        .lte('fecha', endOfDay.toISOString())
        .order('correlativo', { ascending: false })
        .limit(1);

      if (error) {
        throw error;
      }

      const nextCorrelativo = data && data.length > 0 ? (data[0].correlativo || 0) + 1 : 1;
      
      return nextCorrelativo;
    } catch (error) {
      // En caso de error, usar 1 como fallback
      return 1;
    }
  }

  async createSale(sale: Omit<Sale, 'id' | 'createdAt'>): Promise<string> {
    try {
      // Obtener fecha/hora actual en Honduras
      const hondurasTime = this.getHondurasDateTime();
      // Convertir a UTC para guardar en la base de datos
      const utcTime = this.hondurasToUtc(hondurasTime);

      const saleData = {
        user_id: sale.userId,
        sucursal: sale.sucursal,
        sorteo: sale.sorteo,
        fecha: utcTime.toISOString(),
        total: sale.total,
        numero_recibo: sale.numeroRecibo,
        correlativo: sale.correlativo,
        created_at: utcTime.toISOString()
      };

      const { data, error } = await this.supabase
        .from('sales')
        .insert([saleData])
        .select()
        .single();

      if (error) {
        throw error;
      }

      return data.id;
    } catch (error) {
      throw error;
    }
  }

  async createSaleDetail(detail: Omit<SaleDetail, 'id'>): Promise<string> {
    try {
      // Validar que los datos sean válidos
      if (detail.numero === null || detail.numero === undefined) {
        throw new Error('Número no puede ser null o undefined');
      }
      
      if (detail.monto === null || detail.monto === undefined || detail.monto <= 0) {
        throw new Error('Monto debe ser mayor a 0');
      }
      
      // Convertir el número a string con formato de 2 dígitos (00, 01, 02, etc.)
      const numeroString = detail.numero.toString().padStart(2, '0');
      
      const detailData = {
        sale_id: detail.saleId,
        numero: numeroString,  // Enviar como string
        monto: Number(detail.monto)
      };

      const { data, error } = await this.supabase
        .from('sale_details')
        .insert([detailData])
        .select()
        .single();
      
      if (error) {
        throw error;
      }

      return data.id;
    } catch (error) {
      throw error;
    }
  }



  async getSalesByDateAndSorteo(fecha: Date, sorteo: string): Promise<Sale[]> {
    try {
      // Crear rango de fechas para el día seleccionado en hora de Honduras
      const startOfDayHonduras = new Date(fecha);
      startOfDayHonduras.setHours(0, 0, 0, 0);
      const endOfDayHonduras = new Date(fecha);
      endOfDayHonduras.setHours(23, 59, 59, 999);

      // Convertir a UTC para consultar en la base de datos
      const startOfDayUtc = this.hondurasToUtc(startOfDayHonduras);
      const endOfDayUtc = this.hondurasToUtc(endOfDayHonduras);

      let query = this.supabase
        .from('sales')
        .select('*')
        .gte('fecha', startOfDayUtc.toISOString())
        .lte('fecha', endOfDayUtc.toISOString())
        .order('created_at', { ascending: false });

      if (sorteo && sorteo.trim() !== '') {
        query = query.eq('sorteo', sorteo);
      }

      const { data, error } = await query;

      if (error) {
        throw error;
      }
      
      if (!data || data.length === 0) {
        return [];
      }

      const mappedSales = data.map(sale => ({
        id: sale.id,
        userId: sale.user_id,
        sucursal: sale.sucursal,
        sorteo: sale.sorteo,
        fecha: this.parseDateFromDatabase(sale.fecha), // Convertir a hora Honduras
        total: sale.total,
        numeroRecibo: sale.numero_recibo || sale.id.slice(-6),
        correlativo: sale.correlativo || 0,
        createdAt: this.parseDateFromDatabase(sale.created_at) // Convertir a hora Honduras
      })) as Sale[];

      return mappedSales;
    } catch (error) {
      return [];
    }
  }

  async getSaleDetails(saleId: string): Promise<SaleDetail[]> {
    try {
      const { data, error } = await this.supabase
        .from('sale_details')
        .select('*')
        .eq('sale_id', saleId);

      if (error) throw error;

      return data.map(detail => ({
        id: detail.id,
        saleId: detail.sale_id,
        numero: parseInt(detail.numero), // Convertir string a número para la interfaz
        monto: detail.monto
      })) as SaleDetail[];
    } catch (error) {
      return [];
    }
  }

  // Sorteos
  async createOrUpdateSorteo(sorteo: Omit<Sorteo, 'id'>): Promise<string> {
    try {
      const sorteoId = `${sorteo.fecha.toDateString()}-${sorteo.sorteo}`;
      
      // Asegurar formato de string para numero_ganador
      const numeroGanadorString = (sorteo.numeroGanador ?? '').toString().padStart(2, '0');
      
      const sorteoData = {
        id: sorteoId,
        fecha: sorteo.fecha.toISOString(),
        sorteo: sorteo.sorteo,
        hora_cierre: sorteo.horaCierre.toISOString(),
        numero_ganador: numeroGanadorString,
        factor_multiplicador: sorteo.factorMultiplicador,
        total_vendido: sorteo.totalVendido,
        total_pagado: sorteo.totalPagado,
        ganancia_neta: sorteo.gananciaNeta,
        cerrado: sorteo.cerrado
      };

      const { data, error } = await this.supabase
        .from('sorteos')
        .upsert([sorteoData])
        .select()
        .single();

      if (error) throw error;

      return data.id;
    } catch (error) {
      throw error;
    }
  }

  async getSorteo(fecha: Date, sorteo: string): Promise<Sorteo | null> {
    try {
      const sorteoId = `${fecha.toDateString()}-${sorteo}`;
      const { data, error } = await this.supabase
        .from('sorteos')
        .select('*')
        .eq('id', sorteoId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          // No se encontró el registro
          return null;
        }
        throw error;
      }

      return {
        id: data.id,
        fecha: new Date(data.fecha),
        sorteo: data.sorteo,
        horaCierre: new Date(data.hora_cierre),
        // Mantener como string ya que numero_ganador es tipo text
        numeroGanador: data.numero_ganador || '',
        factorMultiplicador: data.factor_multiplicador,
        totalVendido: data.total_vendido,
        totalPagado: data.total_pagado,
        gananciaNeta: data.ganancia_neta,
        cerrado: data.cerrado
      } as Sorteo;
    } catch (error) {
      return null;
    }
  }

  // Método específico para verificar si un sorteo existe por ID
  async getSorteoById(sorteoId: string): Promise<Sorteo | null> {
    try {
      const { data, error } = await this.supabase
        .from('sorteos')
        .select('*')
        .eq('id', sorteoId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          // No se encontró el registro
          return null;
        }
        // Si es un error de permisos (406, RLS), lanzar para manejo especial
        if (error.code === '42501' || error.details?.includes('permission denied')) {
          throw { ...error, isRLSError: true };
        }
        throw error;
      }

      return {
        id: data.id,
        fecha: new Date(data.fecha),
        sorteo: data.sorteo,
        horaCierre: new Date(data.hora_cierre),
        numeroGanador: data.numero_ganador || '',
        factorMultiplicador: data.factor_multiplicador,
        totalVendido: data.total_vendido,
        totalPagado: data.total_pagado,
        gananciaNeta: data.ganancia_neta,
        cerrado: data.cerrado
      } as Sorteo;
    } catch (error) {
      throw error;
    }
  }

  // Método alternativo que usa una consulta sin RLS estricto
  async getSorteoByIdSimple(sorteoId: string): Promise<any> {
    try {
      const { data, error } = await this.supabase
        .rpc('get_sorteo_simple', { sorteo_id: sorteoId });

      if (error) {
        return null;
      }

      return data;
    } catch (error) {
      return null;
    }
  }

  // Método específico para insertar un nuevo sorteo
  async insertNewSorteo(sorteoId: string, numeroGanador: string, factorMultiplicador: number): Promise<void> {
    try {
      
      const numeroString = numeroGanador.toString().padStart(2, '0');
      const hondurasDateTime = this.getHondurasDateTime();
      
      const { error } = await this.supabase
        .from('sorteos')
        .insert({
          id: sorteoId,
          fecha: hondurasDateTime.toISOString(),
          sorteo: sorteoId.split('-').slice(1).join('-'),
          hora_cierre: hondurasDateTime.toISOString(),
          numero_ganador: numeroString,
          factor_multiplicador: factorMultiplicador,
          total_vendido: 0,
          total_pagado: 0,
          ganancia_neta: 0,
          cerrado: true
        });

      if (error) {
        throw error;
      }
      
    } catch (error) {
      throw error;
    }
  }

  async updateSorteoWinner(sorteoId: string, numeroGanador: string, factorMultiplicador: number): Promise<void> {
    try {
      
      // Asegurar formato de 2 dígitos si es número
      const numeroString = numeroGanador.toString().padStart(2, '0');
      
      // Primero intentar hacer un update simple
      const { data: existingData, error: selectError } = await this.supabase
        .from('sorteos')
        .select('id')
        .eq('id', sorteoId)
        .single();
      
      if (selectError && selectError.code !== 'PGRST116') {
        throw selectError;
      }
      
      let result;
      
      if (existingData) {
        // El sorteo existe, hacer update
        result = await this.supabase
          .from('sorteos')
          .update({
            numero_ganador: numeroString,
            factor_multiplicador: factorMultiplicador,
            cerrado: true
          })
          .eq('id', sorteoId);
      } else {
        // El sorteo no existe, hacer insert con las columnas correctas
        const hondurasDateTime = this.getHondurasDateTime();
        result = await this.supabase
          .from('sorteos')
          .insert({
            id: sorteoId,
            fecha: hondurasDateTime.toISOString(),
            sorteo: sorteoId.split('-').slice(1).join('-'), // Extraer nombre del sorteo
            hora_cierre: hondurasDateTime.toISOString(),
            numero_ganador: numeroString,
            factor_multiplicador: factorMultiplicador,
            total_vendido: 0,
            total_pagado: 0,
            ganancia_neta: 0,
            cerrado: true
          });
      }

      if (result.error) {
        throw result.error;
      }
      
      
    } catch (error) {
      throw error;
    }
  }

  async createSorteo(sorteoId: string, sorteoName: string, fecha: Date): Promise<void> {
    try {
      const hondurasDateTime = this.getHondurasDateTime();
      
      const { error } = await this.supabase
        .from('sorteos')
        .insert({
          id: sorteoId,
          fecha: hondurasDateTime.toISOString(),
          sorteo: sorteoName,
          hora_cierre: hondurasDateTime.toISOString(),
          numero_ganador: null,
          factor_multiplicador: 70,
          total_vendido: 0,
          total_pagado: 0,
          ganancia_neta: 0,
          cerrado: false
        });

      if (error) throw error;
    } catch (error) {
      throw error;
    }
  }

  // Método alternativo para actualizar sorteo sin políticas RLS complejas
  async updateSorteoWinnerDirect(sorteoId: string, numeroGanador: string, factorMultiplicador: number): Promise<void> {
    try {
      
      const numeroString = numeroGanador.toString().padStart(2, '0');
      
      const { error } = await this.supabase
        .from('sorteos')
        .update({
          numero_ganador: numeroString,
          factor_multiplicador: factorMultiplicador,
          cerrado: true
        })
        .eq('id', sorteoId);

      if (error) {
        throw error;
      }

      
    } catch (error) {
      throw error;
    }
  }

  // Método súper simple que solo hace UPDATE (último recurso)
  async updateSorteoWinnerSimple(sorteoId: string, numeroGanador: string, factorMultiplicador: number): Promise<void> {
    try {
      
      const numeroString = numeroGanador.toString().padStart(2, '0');
      
      // Solo hacer UPDATE, sin verificaciones
      const { error } = await this.supabase
        .from('sorteos')
        .update({
          numero_ganador: numeroString,
          factor_multiplicador: factorMultiplicador,
          cerrado: true
        })
        .eq('id', sorteoId);
          
      if (error) {
        throw error;
      }

      
    } catch (error) {
      throw error;
    }
  }

  async calculateSorteoWinnings(sorteoId: string): Promise<void> {
    try {
      // Obtener el sorteo
      const { data: sorteo, error: sorteoError } = await this.supabase
        .from('sorteos')
        .select('*')
        .eq('id', sorteoId)
        .single();

      if (sorteoError) throw sorteoError;
      if (!sorteo.numero_ganador) return;

      // Obtener todas las ventas del sorteo
      const { data: sales, error: salesError } = await this.supabase
        .from('sales')
        .select('*, sale_details(*)')
        .eq('sorteo', sorteo.sorteo)
        .gte('fecha', new Date(sorteo.fecha).toISOString().split('T')[0])
        .lt('fecha', new Date(new Date(sorteo.fecha).getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0]);

      if (salesError) throw salesError;

      // Calcular total vendido
      let totalVendido = 0;
      let totalPagado = 0;

      for (const sale of sales) {
        for (const detail of sale.sale_details) {
          totalVendido += detail.monto;
          
          // Comparar números: convertir detail.numero a string para comparar con numero_ganador (text)
          if (detail.numero.toString().padStart(2, '0') === sorteo.numero_ganador) {
            totalPagado += detail.monto * sorteo.factor_multiplicador;
          }
        }
      }

      const gananciaNeta = totalVendido - totalPagado;

      // Actualizar el sorteo con los cálculos
      const { error: updateError } = await this.supabase
        .from('sorteos')
        .update({
          total_vendido: totalVendido,
          total_pagado: totalPagado,
          ganancia_neta: gananciaNeta
        })
        .eq('id', sorteoId);

      if (updateError) throw updateError;
    } catch (error) {
      throw error;
    }
  }

  // Método de debug para verificar conexión y datos
  async debugSalesData(): Promise<void> {
    try {

      // Verificar conexión básica
      const { data: tablesData, error: tablesError } = await this.supabase
        .from('sales')
        .select('count(*)', { count: 'exact', head: true });

      if (tablesError) {
        return;
      }


      // Verificar ventas de hoy sin filtros
      const today = new Date();
      const startOfDay = new Date(today);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(today);
      endOfDay.setHours(23, 59, 59, 999);


      const { data: todayData, error: todayError } = await this.supabase
        .from('sales')
        .select('*')
        .gte('fecha', startOfDay.toISOString())
        .lte('fecha', endOfDay.toISOString());

      if (todayError) {
        return;
      }

      if (todayData && todayData.length > 0) {
      }

      // Verificar ventas de los últimos 3 días
      const threeDaysAgo = new Date(today);
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
      threeDaysAgo.setHours(0, 0, 0, 0);

      const { data: recentData, error: recentError } = await this.supabase
        .from('sales')
        .select('*')
        .gte('fecha', threeDaysAgo.toISOString())
        .order('created_at', { ascending: false })
        .limit(10);

      if (recentError) {
        return;
      }

      if (recentData && recentData.length > 0) {
        recentData.forEach((sale, index) => {
        });
      }

    } catch (error) {
    }
  }

  // Método para verificar permisos y políticas RLS
  async checkDatabasePermissions(): Promise<void> {
    try {
      
      // Verificar sesión actual
      const { data: session, error: sessionError } = await this.supabase.auth.getSession();
      if (sessionError) {
        return;
      }
      
      
      // Probar consulta simple a la tabla sales
      const { data: simpleQuery, error: simpleError } = await this.supabase
        .from('sales')
        .select('id, sucursal, created_at')
        .limit(1);
      
      if (simpleError) {
      } else {
      }
      
      // Probar inserción de test (para verificar permisos de escritura)
      const testSale = {
        user_id: session?.session?.user?.id || 'test-user',
        sucursal: 'TEST',
        sorteo: 'test',
        fecha: new Date().toISOString(),
        total: 0,
        numero_recibo: 'TEST-001',
        correlativo: 999
      };
      
      const { data: insertTest, error: insertError } = await this.supabase
        .from('sales')
        .insert(testSale)
        .select();
      
      if (insertError) {
      } else {
        
        // Eliminar el registro de prueba
        if (insertTest && insertTest.length > 0) {
          await this.supabase
            .from('sales')
            .delete()
            .eq('id', insertTest[0].id);
        }
      }
      
    } catch (error) {
    }
  }

  // ========================
  // GESTIÓN DE USUARIOS
  // ========================

  async getUsers(): Promise<User[]> {
    try {
      
      // Retornar usuarios por defecto simples para que funcione
      return [
        {
          id: '1',
          email: 'gerencia@loteria.com',
          role: 'admin',
          sucursal: '',
          active: true,
          createdAt: new Date()
        },
        {
          id: '2', 
          email: 'venta1@loteria.com',
          role: 'sucursal',
          sucursal: 'Sucursal 1',
          active: true,
          createdAt: new Date()
        },
        {
          id: '3',
          email: 'venta2@loteria.com', 
          role: 'sucursal',
          sucursal: 'Sucursal 2',
          active: true,
          createdAt: new Date()
        },
        {
          id: '4',
          email: 'venta3@loteria.com',
          role: 'sucursal', 
          sucursal: 'Sucursal 3',
          active: true,
          createdAt: new Date()
        },
        {
          id: '5',
          email: 'venta4@loteria.com',
          role: 'sucursal',
          sucursal: 'Sucursal 4', 
          active: true,
          createdAt: new Date()
        }
      ];
    } catch (error) {
      return [];
    }
  }

  private getDefaultUsers(): User[] {
    return [
      {
        id: '1',
        email: 'admin@loteria.com',
        role: 'admin',
        sucursal: '',
        active: true,
        createdAt: new Date()
      },
      {
        id: '2',
        email: 'sucursal1@loteria.com',
        role: 'sucursal',
        sucursal: 'Sucursal 1',
        active: true,
        createdAt: new Date()
      }
    ];
  }

  private async createProfilesFromAuthUsers(authUsers: any[]): Promise<void> {
    try {
      const profilesData = authUsers.map(authUser => ({
        id: authUser.id,
        email: authUser.email,
        role: authUser.email?.includes('admin') || authUser.email === 'gerencia@loteria.com' ? 'admin' : 'sucursal',
        sucursal: this.getSucursalFromEmail(authUser.email || ''),
        active: true,
        created_at: new Date(authUser.created_at).toISOString()
      }));

      const { error } = await this.supabase
        .from('profiles')
        .upsert(profilesData, { onConflict: 'id' });

      if (error) {
      } else {
      }
    } catch (error) {
    }
  }

  async updateUserPassword(userId: string, newPassword: string): Promise<void> {
    try {
      const { error } = await this.supabase.auth.updateUser({
        password: newPassword
      });

      if (error) {
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }

  // ========================
  // GESTIÓN DE SORTEOS
  // ========================

  async getSorteoSchedules(): Promise<any[]> {
    try {
      
      const { data, error } = await this.supabase
        .from('sorteo_schedules')
        .select('*')
        .order('close_time', { ascending: true });

      if (error) {
        throw error;
      }

      return data || [];
    } catch (error) {
      throw error;
    }
  }

  async createSorteoSchedule(sorteoData: { name: string, label: string, close_time: string }): Promise<any> {
    try {
      const { data, error } = await this.supabase
        .from('sorteo_schedules')
        .insert([sorteoData])
        .select()
        .single();

      if (error) {
        throw error;
      }

      return data;
    } catch (error) {
      throw error;
    }
  }

  async updateSorteoSchedule(sorteoId: string, updates: { name?: string, label?: string, close_time?: string }): Promise<any> {
    try {
      const { data, error } = await this.supabase
        .from('sorteo_schedules')
        .update(updates)
        .eq('id', sorteoId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      return data;
    } catch (error) {
      throw error;
    }
  }

  async deleteSorteoSchedule(sorteoId: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('sorteo_schedules')
        .delete()
        .eq('id', sorteoId);

      if (error) {
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }

  // ========================
  // MÉTODOS DE DEBUG Y SETUP
  // ========================
 

  async initializeSorteoSchedules(): Promise<void> {
    try {
      // Crear los sorteos por defecto si no existen
      const defaultSorteos: SorteoSchedule[] = [...SORTEO_SCHEDULES];

      for (const sorteo of defaultSorteos) {
        const { error } = await this.supabase
          .from('sorteo_schedules')
          .upsert(sorteo, { onConflict: 'name' });

        if (error) {
        } else {
        }
      }
    } catch (error) {
    }
  }

  // Método para inicializar la tabla de perfiles si no existe
  async initializeProfilesTable(): Promise<void> {
    try {
      
      // Simplemente intentar hacer una consulta para ver si la tabla existe
      const { error } = await this.supabase
        .from('profiles')
        .select('count', { count: 'exact', head: true });
      
      if (error) {
      } else {
      }
    } catch (error) {
    }
  }

  // Método para sincronizar usuarios manualmente
  async syncUsersFromAuth(): Promise<void> {
    try {
    } catch (error) {
    }
  }

  // ========== FUNCIONES DE TIMEZONE HONDURAS CON DATE-FNS-TZ ==========
  private readonly HONDURAS_TIMEZONE = 'America/Tegucigalpa';

  // Función para obtener la fecha/hora actual en Honduras
  getHondurasDateTime(): Date {
    const now = new Date();
    return toZonedTime(now, this.HONDURAS_TIMEZONE);
  }

  // Función para formatear fecha/hora en formato de Honduras
  formatHondurasDateTime(date?: Date): string {
    const targetDate = date || new Date();
    return formatInTimeZone(targetDate, this.HONDURAS_TIMEZONE, 'yyyy-MM-dd hh:mm:ss a', { 
      locale: es 
    });
  }

  // Función para convertir una fecha de Honduras a UTC para guardar en BD
  private hondurasToUtc(date: Date): Date {
    return fromZonedTime(date, this.HONDURAS_TIMEZONE);
  }

  // Función para convertir una fecha UTC de BD a hora de Honduras
  private utcToHonduras(utcDate: Date): Date {
    return toZonedTime(utcDate, this.HONDURAS_TIMEZONE);
  }

  // Método público para convertir cualquier fecha a hora de Honduras
  convertToHondurasTime(date: Date): Date {
    return toZonedTime(date, this.HONDURAS_TIMEZONE);
  }

  // Método público para que los componentes obtengan la hora de Honduras
  getHondurasTimeNow(): Date {
    return this.getHondurasDateTime();
  }

  // Método público para formatear fechas en hora de Honduras con formato legible
  formatDateForHonduras(date?: Date): string {
    const targetDate = date || new Date();
    return formatInTimeZone(targetDate, this.HONDURAS_TIMEZONE, 'dd/MM/yyyy hh:mm:ss a', { 
      locale: es 
    });
  }

  // Método público para parsear fechas de la base de datos a hora de Honduras
  parseDateFromDatabase(isoString: string): Date {
    const utcDate = parseISO(isoString);
    return toZonedTime(utcDate, this.HONDURAS_TIMEZONE);
  }

  // ============= MÉTODOS DE GESTIÓN DE USUARIOS =============

  // Obtener todos los usuarios del sistema
  async getAllUsers(): Promise<User[]> {
    try {
      const { data, error } = await this.supabase
        .from('users')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }

      return data.map(user => ({
        id: user.id,
        email: user.email,
        role: user.role,
        sucursal: user.sucursal,
        active: user.active,
        createdAt: new Date(user.created_at)
      }));
    } catch (error) {
      throw error;
    }
  }

  // Crear un nuevo usuario en el sistema
  async createNewUser(userData: { email: string; role: 'admin' | 'sucursal'; sucursal?: string; active?: boolean }): Promise<User> {
    try {
      // Primero crear el usuario en Auth
      const { data: authData, error: authError } = await this.supabase.auth.admin.createUser({
        email: userData.email,
        password: 'LoteriaTemporal123!', // Contraseña temporal
        email_confirm: true
      });

      if (authError) {
        throw authError;
      }

      // Luego insertar en la tabla users
      const userRecord = {
        id: authData.user.id,
        email: userData.email,
        role: userData.role,
        sucursal: userData.sucursal || null,
        active: userData.active !== undefined ? userData.active : true,
        created_at: new Date().toISOString()
      };

      const { data, error } = await this.supabase
        .from('users')
        .insert([userRecord])
        .select()
        .single();

      if (error) {
        // Si falla la inserción en users, intentar eliminar el usuario de Auth
        await this.supabase.auth.admin.deleteUser(authData.user.id);
        throw error;
      }

      return {
        id: data.id,
        email: data.email,
        role: data.role,
        sucursal: data.sucursal,
        active: data.active,
        createdAt: new Date(data.created_at)
      };
    } catch (error) {
      throw error;
    }
  }

  // Actualizar un usuario existente
  async updateExistingUser(userId: string, updates: { email?: string; role?: 'admin' | 'sucursal'; sucursal?: string; active?: boolean }): Promise<User> {
    try {
      // Actualizar en Auth si hay cambio de email
      if (updates.email) {
        const { error: authError } = await this.supabase.auth.admin.updateUserById(userId, {
          email: updates.email
        });

        if (authError) {
          throw authError;
        }
      }

      // Actualizar en la tabla users
      const { data, error } = await this.supabase
        .from('users')
        .update({
          email: updates.email,
          role: updates.role,
          sucursal: updates.sucursal,
          active: updates.active
        })
        .eq('id', userId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      return {
        id: data.id,
        email: data.email,
        role: data.role,
        sucursal: data.sucursal,
        active: data.active,
        createdAt: new Date(data.created_at)
      };
    } catch (error) {
      throw error;
    }
  }

  // Eliminar un usuario del sistema
  async deleteExistingUser(userId: string): Promise<void> {
    try {
      // Primero eliminar de la tabla users
      const { error: dbError } = await this.supabase
        .from('users')
        .delete()
        .eq('id', userId);

      if (dbError) {
        throw dbError;
      }

      // Luego eliminar de Auth
      const { error: authError } = await this.supabase.auth.admin.deleteUser(userId);

      if (authError) {
        // Si falla eliminar de Auth, intentar restaurar en la tabla users
        // (esto es complejo, por ahora solo lanzamos el error)
        throw authError;
      }
    } catch (error) {
      throw error;
    }
  }

  // Alternar el estado activo/inactivo de un usuario
  async toggleExistingUserStatus(userId: string): Promise<User> {
    try {
      // Primero obtener el estado actual
      const { data: currentData, error: fetchError } = await this.supabase
        .from('users')
        .select('active')
        .eq('id', userId)
        .single();

      if (fetchError) {
        throw fetchError;
      }

      // Alternar el estado
      const newStatus = !currentData.active;

      // Actualizar en la base de datos
      const { data, error } = await this.supabase
        .from('users')
        .update({ active: newStatus })
        .eq('id', userId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      return {
        id: data.id,
        email: data.email,
        role: data.role,
        sucursal: data.sucursal,
        active: data.active,
        createdAt: new Date(data.created_at)
      };
    } catch (error) {
      throw error;
    }
  }

  // Enviar email de restablecimiento de contraseña
  async sendPasswordReset(email: string): Promise<void> {
    try {
      const { error } = await this.supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/reset-password`
      });

      if (error) {
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }

}
